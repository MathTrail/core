План для Claude: Внедрение PgBouncer в infra
Контекст:
Микросервисы MathTrail (Go + Dapr) создают высокую нагрузку на PostgreSQL. Нам нужно внедрить PgBouncer в режиме Transaction Pooling, чтобы эффективно утилизировать ресурсы CPU и избежать ошибки too many connections.

Задачи:

1. Обновление Helm-чартов (infra/charts/postgres)
Добавь зависимость на официальный чарт PgBouncer или интегрируй его как sidecar/standalone деплоймент.

Конфигурация (pgbouncer.ini):

pool_mode = transaction (оптимально для микросервисов).

max_client_conn = 1000 (сколько микросервисов могут "стучаться").

default_pool_size = 20 (сколько реальных соединений держать к базе).

Настрой Service в Kubernetes, чтобы микросервисы ходили на порт 6432 вместо стандартного 5432.

2. Безопасность и Auth
Настрой проброс секретов через userlist.txt.

Реализуй автоматическое обновление паролей в PgBouncer при их ротации в Postgres (используй auth_query или общий Secret).

3. Observability (OpenTelemetry)
Добавь PgBouncer Exporter.

Сконфигурируй OpenTelemetry Collector, чтобы он забирал метрики пула (активные соединения, время ожидания в очереди, количество заброшенных коннектов).

Добавь панель в Grafana, чтобы видеть "бутылочное горлышко": если очереди в PgBouncer растут — пора масштабировать базу или увеличивать пул.

4. Миграция микросервисов
Подготовь Bash-скрипт или обнови values.yaml для всех 16 сервисов, чтобы переменная окружения DATABASE_URL теперь указывала на хост PgBouncer.

Важный нюанс: Проверь, чтобы сервисы не использовали Prepared Statements (или настрой PgBouncer соответствующим образом), так как в режиме transaction pooling они могут работать некорректно.

5. Тестирование (k6)
Обнови сценарии в infra-testing.

Добавь тест на «шторм соединений»: запусти k6 с резким всплеском VUs (Virtual Users) и убедись, что Postgres не упал, а PgBouncer плавно распределил нагрузку.